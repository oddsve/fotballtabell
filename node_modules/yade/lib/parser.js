// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var Lexer, Parser, constantinople, filters, nodes, parseJSExpression, path, utils;

  Lexer = require('./lexer');

  nodes = require('./nodes');

  utils = require('./utils');

  filters = require('./filters');

  path = require('path');

  constantinople = require('constantinople');

  parseJSExpression = require('character-parser').parseMax;


  /**
   * Parser prototype.
   */

  Parser = (function() {

    /**
     * Initialize `Parser` with the given input `str` and `filename`.
     * @param {String} str
     * @param {String} filename
     * @param {Object} options
     * @api public
     */
    function Parser(str, filename, options) {
      this.input = str.replace(/^\uFEFF/, '');
      this.lexer = new Lexer(this.input, filename);
      this.filename = filename;
      this.blocks = {};
      this.mixins = {};
      this.options = options;
      this.contexts = [this];
      this.inMixin = false;
      this.dependencies = [];
      return;
    }


    /**
     * Push `parser` onto the context stack, or pop and return a `Parser`.
     */

    Parser.prototype.context = function(parser) {
      if (parser) {
        this.contexts.push(parser);
      } else {
        return this.contexts.pop();
      }
    };


    /**
     * Return the next token object.
     * @return {Object}
     * @api private
     */

    Parser.prototype.advance = function() {
      return this.lexer.advance();
    };


    /**
     * Single token lookahead.
     * @return {Object}
     * @api private
     */

    Parser.prototype.peek = function() {
      return this.lookahead(1);
    };


    /*
     * Return lexer lineno.
     * @return {Number}
     * @api private
     */

    Parser.prototype.line = function() {
      return this.lexer.lineno;
    };


    /**
     * `n` token lookahead.
     * @param {Number} n
     * @return {Object}
     * @api private
     */

    Parser.prototype.lookahead = function(n) {
      return this.lexer.lookahead(n);
    };


    /**
     * Parse input returning a string of js for evaluation.
     * @return {String}
     * @api public
     */

    Parser.prototype.parse = function() {
      var ast, block, blocks, expr, name, next, parser;
      block = new nodes.Block;
      parser = void 0;
      block.line = 0;
      block.filename = this.filename;
      while (this.peek().type !== 'eos') {
        if (this.peek().type === 'newline') {
          this.advance();
        } else {
          next = this.peek();
          expr = this.parseExpr();
          expr.filename = expr.filename || this.filename;
          expr.line = next.line;
          block.push(expr);
        }
      }
      if (parser = this.extending) {
        this.context(parser);
        ast = parser.parse();
        this.context();
        for (name in this.mixins) {
          ast.unshift(this.mixins[name]);
        }
        return ast;
      }
      if (!this.extending && !this.included && Object.keys(this.blocks).length) {
        blocks = [];
        utils.walkAST(block, function(node) {
          if (node.type === 'Block' && node.name) {
            blocks.push(node.name);
          }
        });
        Object.keys(this.blocks).forEach(((function(_this) {
          return function(name) {
            if (blocks.indexOf(name) === -1) {
              console.warn("Warning: Unexpected block \"" + name + "\" on line " + _this.blocks[name].line + " of " + _this.blocks[name].filename + ". This block is never used. This warning will be an error in v2.0.0");
            }
          };
        })(this)));
      }
      return block;
    };


    /**
     * Expect the given type, or throw an exception.
     * @param {String} type
     * @api private
     */

    Parser.prototype.expect = function(type) {
      if (this.peek().type === type) {
        return this.advance();
      } else {
        throw new Error("expected \"" + type + "\", but got \"" + (this.peek().type) + "\"");
      }
    };


    /**
     * Accept the given `type`.
     * @param {String} type
     * @api private
     */

    Parser.prototype.accept = function(type) {
      if (this.peek().type === type) {
        return this.advance();
      }
    };


    /**
     * tag
     * | doctype
     * | mixin
     * | include
     * | filter
     * | comment
     * | text
     * | each
     * | code
     * | yield
     * | id
     * | class
     * | interpolation
     */

    Parser.prototype.parseExpr = function() {
      var block, tok;
      switch (this.peek().type) {
        case 'tag':
          return this.parseTag();
        case 'mixin':
          return this.parseMixin();
        case 'block':
          return this.parseBlock();
        case 'mixin-block':
          return this.parseMixinBlock();
        case 'case':
          return this.parseCase();
        case 'extends':
          return this.parseExtends();
        case 'include':
          return this.parseInclude();
        case 'doctype':
          return this.parseDoctype();
        case 'filter':
          return this.parseFilter();
        case 'comment':
          return this.parseComment();
        case 'text':
          return this.parseText();
        case 'each':
          return this.parseEach();
        case 'code':
          return this.parseCode();
        case 'call':
          return this.parseCall();
        case 'interpolation':
          return this.parseInterpolation();
        case 'yield':
          this.advance();
          block = new nodes.Block;
          block["yield"] = true;
          return block;
        case 'id':
        case 'class':
          tok = this.advance();
          this.lexer.defer(this.lexer.tok('tag', 'div'));
          this.lexer.defer(tok);
          return this.parseExpr();
        default:
          throw new Error("unexpected token \"" + (this.peek().type) + "\"");
      }
    };


    /**
     * Text
     */

    Parser.prototype.parseText = function() {
      var i, node, tok, tokens, _i, _ref;
      tok = this.expect('text');
      tokens = this.parseInlineTagsInText(tok.val);
      if (tokens.length === 1) {
        return tokens[0];
      }
      node = new nodes.Block;
      for (i = _i = 0, _ref = tokens.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        node.push(tokens[i]);
      }
      return node;
    };


    /**
     * ':' expr
     * | block
     */

    Parser.prototype.parseBlockExpansion = function() {
      if (this.peek().type === ':') {
        this.advance();
        return new nodes.Block(this.parseExpr());
      } else {
        return this.block();
      }
    };


    /**
     * case
     */

    Parser.prototype.parseCase = function() {
      var block, node, val;
      val = this.expect('case').val;
      node = new nodes.Case(val);
      node.line = this.line();
      block = new nodes.Block;
      block.line = this.line();
      block.filename = this.filename;
      this.expect('indent');
      while (this.peek().type !== 'outdent') {
        switch (this.peek().type) {
          case 'newline':
            this.advance();
            break;
          case 'when':
            block.push(this.parseWhen());
            break;
          case 'default':
            block.push(this.parseDefault());
            break;
          default:
            throw new Error("Unexpected token \"" + (this.peek().type) + "\", expected \"when\", \"default\" or \"newline\"");
        }
      }
      this.expect('outdent');
      node.block = block;
      return node;
    };


    /**
     * when
     */

    Parser.prototype.parseWhen = function() {
      var val;
      val = this.expect('when').val;
      if (this.peek().type !== 'newline') {
        return new nodes.Case.When(val, this.parseBlockExpansion());
      } else {
        return new nodes.Case.When(val);
      }
    };


    /**
     * default
     */

    Parser.prototype.parseDefault = function() {
      this.expect('default');
      return new nodes.Case.When('default', this.parseBlockExpansion());
    };


    /**
     * code
     */

    Parser.prototype.parseCode = function(afterIf) {
      var block, node, tok;
      tok = this.expect('code');
      node = new nodes.Code(tok.val, tok.buffer, tok.escape);
      block = void 0;
      node.line = this.line();
      if (tok.isElse && !tok.hasIf) {
        throw new Error('Unexpected else without if');
      }
      block = this.peek().type === 'indent';
      if (block) {
        node.block = this.block();
      }
      if (tok.requiresBlock && !block) {
        node.block = new nodes.Block();
      }
      if (tok.isIf && this.peek().isElse) {
        this.peek().hasIf = true;
      } else if (tok.isIf && this.peek().type === 'newline' && this.lookahead(2).isElse) {
        this.lookahead(2).hasIf = true;
      }
      return node;
    };


    /**
     * comment
     */

    Parser.prototype.parseComment = function() {
      var block, node, tok;
      tok = this.expect('comment');
      node = void 0;
      block = void 0;
      if (block = this.parseTextBlock()) {
        node = new nodes.BlockComment(tok.val, block, tok.buffer);
      } else {
        node = new nodes.Comment(tok.val, tok.buffer);
      }
      node.line = this.line();
      return node;
    };


    /**
     * doctype
     */

    Parser.prototype.parseDoctype = function() {
      var node, tok;
      tok = this.expect('doctype');
      node = new nodes.Doctype(tok.val);
      node.line = this.line();
      return node;
    };


    /**
     * filter attrs? text-block
     */

    Parser.prototype.parseFilter = function() {
      var attrs, block, node, options, tok;
      tok = this.expect('filter');
      attrs = this.accept('attrs');
      block = void 0;
      block = this.parseTextBlock() || new nodes.Block();
      options = {};
      if (attrs) {
        attrs.attrs.forEach(function(attribute) {
          options[attribute.name] = constantinople.toConstant(attribute.val);
        });
      }
      node = new nodes.Filter(tok.val, block, options);
      node.line = this.line();
      return node;
    };


    /**
     * each block
     */

    Parser.prototype.parseEach = function() {
      var node, tok;
      tok = this.expect('each');
      node = new nodes.Each(tok.code, tok.val, tok.key);
      node.line = this.line();
      node.block = this.block();
      if (this.peek().type === 'code' && this.peek().val === 'else') {
        this.advance();
        node.alternative = this.block();
      }
      return node;
    };


    /**
     * Resolves a path relative to the template for use in includes and extends
     * @param {String}  path
     * @param {String}  purpose  Used in error messages.
     * @return {String}
     * @api private
     */

    Parser.prototype.resolvePath = function(path, purpose) {
      var basename, dirname, join, p;
      p = require('path');
      dirname = p.dirname;
      basename = p.basename;
      join = p.join;
      if (path[0] !== '/' && !this.filename) {
        throw new Error("the \"filename\" option is required to use \"" + purpose + "\" with \"relative\" paths");
      }
      if (path[0] === '/' && !this.options.basedir) {
        throw new Error("the \"basedir\" option is required to use \"" + purpose + "\" with \"absolute\" paths");
      }
      path = join((path[0] === '/' ? this.options.basedir : dirname(this.filename)), path);
      if (basename(path).indexOf('.') === -1) {
        path += '.jade';
      }
      return path;
    };


    /**
     * 'extends' name
     */

    Parser.prototype.parseExtends = function() {
      var fs, parser, str;
      fs = require('graceful-fs');
      path = this.resolvePath(this.expect('extends').val.trim(), 'extends');
      if ('.jade' !== path.substr(-5)) {
        path += '.jade';
      }
      this.dependencies.push(path);
      str = fs.readFileSync(path, 'utf8');
      parser = new Parser(str, path, this.options);
      parser.dependencies = this.dependencies;
      parser.blocks = this.blocks;
      parser.contexts = this.contexts;
      this.extending = parser;
      return new nodes.Literal('');
    };


    /**
     * 'block' name block
     */

    Parser.prototype.parseBlock = function() {
      var allNodes, block, mode, name, prev;
      block = this.expect('block');
      mode = block.mode;
      name = block.val.trim();
      block = (this.peek().type === 'indent' ? this.block() : new nodes.Block(new nodes.Literal('')));
      block.name = name;
      prev = this.blocks[name] || {
        prepended: [],
        appended: []
      };
      if (prev.mode === 'replace') {
        return this.blocks[name] = prev;
      }
      allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);
      switch (mode) {
        case 'append':
          prev.appended = (prev.parser === this ? prev.appended.concat(block.nodes) : block.nodes.concat(prev.appended));
          break;
        case 'prepend':
          prev.prepended = (prev.parser === this ? block.nodes.concat(prev.prepended) : prev.prepended.concat(block.nodes));
      }
      block.nodes = allNodes;
      block.appended = prev.appended;
      block.prepended = prev.prepended;
      block.mode = mode;
      block.parser = this;
      return this.blocks[name] = block;
    };

    Parser.prototype.parseMixinBlock = function() {
      var block;
      block = this.expect('mixin-block');
      if (!this.inMixin) {
        throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');
      }
      return new nodes.MixinBlock();
    };


    /**
     * include block?
     */

    Parser.prototype.parseInclude = function() {
      var ast, fs, options, parser, str, tok;
      fs = require('graceful-fs');
      tok = this.expect('include');
      path = this.resolvePath(tok.val.trim(), 'include');
      this.dependencies.push(path);
      if (tok.filter) {
        str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
        options = {
          filename: path
        };
        if (tok.attrs) {
          tok.attrs.attrs.forEach(function(attribute) {
            options[attribute.name] = constantinople.toConstant(attribute.val);
          });
        }
        str = filters(tok.filter, str, options);
        return new nodes.Literal(str);
      }
      if ('.jade' !== path.substr(-5)) {
        str = fs.readFileSync(path, 'utf8').replace(/\r/g, '');
        return new nodes.Literal(str);
      }
      str = fs.readFileSync(path, 'utf8');
      parser = new Parser(str, path, this.options);
      parser.dependencies = this.dependencies;
      parser.blocks = utils.merge({}, this.blocks);
      parser.included = true;
      parser.mixins = this.mixins;
      this.context(parser);
      ast = parser.parse();
      this.context();
      ast.filename = path;
      if (this.peek().type === 'indent') {
        ast.includeBlock().push(this.block());
      }
      return ast;
    };


    /**
     * call ident block
     */

    Parser.prototype.parseCall = function() {
      var args, mixin, name, tok;
      tok = this.expect('call');
      name = tok.val;
      args = tok.args;
      mixin = new nodes.Mixin(name, args, new nodes.Block, true);
      this.tag(mixin);
      if (mixin.code) {
        mixin.block.push(mixin.code);
        mixin.code = null;
      }
      if (mixin.block.isEmpty()) {
        mixin.block = null;
      }
      return mixin;
    };


    /**
     * mixin block
     */

    Parser.prototype.parseMixin = function() {
      var args, mixin, name, tok;
      tok = this.expect('mixin');
      name = tok.val;
      args = tok.args;
      mixin = void 0;
      if (this.peek().type === 'indent') {
        this.inMixin = true;
        mixin = new nodes.Mixin(name, args, this.block(), false);
        this.mixins[name] = mixin;
        this.inMixin = false;
        return mixin;
      } else {
        return new nodes.Mixin(name, args, null, true);
      }
    };

    Parser.prototype.parseInlineTagsInText = function(str) {
      var buffer, inner, line, match, range, rest, text;
      line = this.line();
      match = /(\\)?#\[((?:.|\n)*)$/.exec(str);
      if (match) {
        if (match[1]) {
          text = new nodes.Text(str.substr(0, match.index) + '#[');
          text.line = line;
          rest = this.parseInlineTagsInText(match[2]);
          if (rest[0].type === 'Text') {
            text.val += rest[0].val;
            rest.shift();
          }
          return [text].concat(rest);
        } else {
          text = new nodes.Text(str.substr(0, match.index));
          text.line = line;
          buffer = [text];
          rest = match[2];
          range = parseJSExpression(rest);
          inner = new Parser(range.src, this.filename, this.options);
          buffer.push(inner.parse());
          return buffer.concat(this.parseInlineTagsInText(rest.substr(range.end + 1)));
        }
      } else {
        text = new nodes.Text(str);
        text.line = line;
        return [text];
      }
    };


    /**
     * indent (text | newline)* outdent
     */

    Parser.prototype.parseTextBlock = function() {
      var block, body;
      block = new nodes.Block;
      block.line = this.line();
      body = this.peek();
      if (body.type !== 'pipeless-text') {
        return;
      }
      this.advance();
      block.nodes = body.val.reduce(((function(_this) {
        return function(accumulator, text) {
          return accumulator.concat(_this.parseInlineTagsInText(text));
        };
      })(this)), []);
      return block;
    };


    /**
     * indent expr* outdent
     */

    Parser.prototype.block = function() {
      var block, expr;
      block = new nodes.Block;
      block.line = this.line();
      block.filename = this.filename;
      this.expect('indent');
      while (this.peek().type !== 'outdent') {
        if (this.peek().type === 'newline') {
          this.advance();
        } else {
          expr = this.parseExpr();
          expr.filename = this.filename;
          block.push(expr);
        }
      }
      this.expect('outdent');
      return block;
    };


    /**
     * interpolation (attrs | class | id)* (text | code | ':')? newline* block?
     */

    Parser.prototype.parseInterpolation = function() {
      var tag, tok;
      tok = this.advance();
      tag = new nodes.Tag(tok.val);
      tag.buffer = true;
      return this.tag(tag);
    };


    /**
     * tag (attrs | class | id)* (text | code | ':')? newline* block?
     */

    Parser.prototype.parseTag = function() {
      var tag, tok;
      tok = this.advance();
      tag = new nodes.Tag(tok.val);
      tag.selfClosing = tok.selfClosing;
      return this.tag(tag);
    };

    Parser.prototype.tag = function(tag) {
      var attrs, breakOut, i, node, seenAttrs, tok, _i, _j, _len, _ref, _ref1;
      tag.line = this.line();
      seenAttrs = false;
      breakOut = false;
      while (!breakOut) {
        switch (this.peek().type) {
          case 'class':
          case 'id':
            tok = this.advance();
            tag.setAttribute(tok.type, "'" + tok.val + "'");
            break;
          case 'attrs':
            if (seenAttrs) {
              console.warn("" + this.filename + ", line " + (this.peek().line) + ":\nYou should not have jade tags with multiple attributes.");
            }
            seenAttrs = true;
            tok = this.advance();
            attrs = tok.attrs;
            if (tok.selfClosing) {
              tag.selfClosing = true;
            }
            for (i = _i = 0, _ref = attrs.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);
            }
            break;
          case '&attributes':
            tok = this.advance();
            tag.addAttributes(tok.val);
            break;
          default:
            breakOut = true;
        }
      }
      if (this.peek().type === 'dot') {
        tag.textOnly = true;
        this.advance();
      }
      switch (this.peek().type) {
        case 'text':
          tag.block.push(this.parseText());
          break;
        case 'code':
          tag.code = this.parseCode();
          break;
        case ':':
          this.advance();
          tag.block = new nodes.Block;
          tag.block.push(this.parseExpr());
          break;
        case 'newline':
        case 'indent':
        case 'outdent':
        case 'eos':
        case 'pipeless-text':
          break;
        default:
          throw new Error("Unexpected token `" + (this.peek().type) + "` expected `text`, `code`, `:`, `newline` or `eos`");
      }
      while (this.peek().type === 'newline') {
        this.advance();
      }
      if (tag.textOnly) {
        tag.block = this.parseTextBlock();
      } else if (this.peek().type === 'indent') {
        _ref1 = this.block().nodes;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          node = _ref1[_j];
          tag.block.push(node);
        }
      }
      return tag;
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
